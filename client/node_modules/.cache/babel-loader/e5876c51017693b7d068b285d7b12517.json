{"ast":null,"code":"import * as fcl from \"@onflow/fcl\"; //import { getConfig } from \"../../config\";\n\nimport { sign } from \"./sign\";\n\nfunction getConfig() {\n  const minterAddress = fcl.withPrefix(process.env.REACT_APP_NSFT_CONTRACT);\n  const minterPrivateKeyHex = process.env.REACT_APP_NSFT_PRIVATE_KEY;\n  const minterAccountKeyIndex = process.env.REACT_APP_NSFT_ACCOUNT_KEY_INDEX || 0;\n  return {\n    minterAddress,\n    minterPrivateKeyHex,\n    minterAccountKeyIndex\n  };\n}\n\nconst ADDRESS = getConfig().minterAddress;\nconst KEY_ID = getConfig().minterAccountKeyIndex;\nexport const authorizationFunction = async account => {\n  // authorization function need to return an account\n  return { ...account,\n    // bunch of defaults in here, we want to overload some of them though\n    tempId: `${ADDRESS}|${KEY_ID}`,\n    // tempIds are more of an advanced topic, for 99% of the times where you know the address and keyId you will want it to be a unique string per that address and keyId\n    addr: fcl.sansPrefix(ADDRESS),\n    // the address of the signatory, currently it needs to be without a prefix right now\n    keyId: Number(KEY_ID),\n    // this is the keyId for the accounts registered key that will be used to sign, make extra sure this is a number and not a string\n    signingFunction: async signable => {\n      // Singing functions are passed a signable and need to return a composite signature\n      // signable.message is a hex string of what needs to be signed.\n      return {\n        addr: fcl.withPrefix(ADDRESS),\n        // needs to be the same as the account.addr but this time with a prefix, eventually they will both be with a prefix\n        keyId: Number(KEY_ID),\n        // needs to be the same as account.keyId, once again make sure its a number and not a string\n        signature: sign(getConfig().minterPrivateKeyHex, signable.message) // this needs to be a hex string of the signature, where signable.message is the hex value that needs to be signed\n\n      };\n    }\n  };\n};","map":{"version":3,"sources":["/Users/aidanhall/Desktop/nsft-v3/client/src/services/authorization-function.js"],"names":["fcl","sign","getConfig","minterAddress","withPrefix","process","env","REACT_APP_NSFT_CONTRACT","minterPrivateKeyHex","REACT_APP_NSFT_PRIVATE_KEY","minterAccountKeyIndex","REACT_APP_NSFT_ACCOUNT_KEY_INDEX","ADDRESS","KEY_ID","authorizationFunction","account","tempId","addr","sansPrefix","keyId","Number","signingFunction","signable","signature","message"],"mappings":"AAAA,OAAO,KAAKA,GAAZ,MAAqB,aAArB,C,CACA;;AACA,SAASC,IAAT,QAAqB,QAArB;;AAEA,SAASC,SAAT,GAAqB;AACjB,QAAMC,aAAa,GAAGH,GAAG,CAACI,UAAJ,CAAeC,OAAO,CAACC,GAAR,CAAYC,uBAA3B,CAAtB;AACA,QAAMC,mBAAmB,GAAGH,OAAO,CAACC,GAAR,CAAYG,0BAAxC;AACA,QAAMC,qBAAqB,GACzBL,OAAO,CAACC,GAAR,CAAYK,gCAAZ,IAAgD,CADlD;AAGA,SAAO;AACLR,IAAAA,aADK;AAELK,IAAAA,mBAFK;AAGLE,IAAAA;AAHK,GAAP;AAKD;;AAEH,MAAME,OAAO,GAAGV,SAAS,GAAGC,aAA5B;AACA,MAAMU,MAAM,GAAGX,SAAS,GAAGQ,qBAA3B;AAEA,OAAO,MAAMI,qBAAqB,GAAG,MAAOC,OAAP,IAAmB;AACtD;AACA,SAAO,EACL,GAAGA,OADE;AACO;AACZC,IAAAA,MAAM,EAAG,GAAEJ,OAAQ,IAAGC,MAAO,EAFxB;AAE2B;AAChCI,IAAAA,IAAI,EAAEjB,GAAG,CAACkB,UAAJ,CAAeN,OAAf,CAHD;AAG0B;AAC/BO,IAAAA,KAAK,EAAEC,MAAM,CAACP,MAAD,CAJR;AAIkB;AACvBQ,IAAAA,eAAe,EAAE,MAAOC,QAAP,IAAoB;AACnC;AACA;AACA,aAAO;AACLL,QAAAA,IAAI,EAAEjB,GAAG,CAACI,UAAJ,CAAeQ,OAAf,CADD;AAC0B;AAC/BO,QAAAA,KAAK,EAAEC,MAAM,CAACP,MAAD,CAFR;AAEkB;AACvBU,QAAAA,SAAS,EAAEtB,IAAI,CAACC,SAAS,GAAGM,mBAAb,EAAkCc,QAAQ,CAACE,OAA3C,CAHV,CAG+D;;AAH/D,OAAP;AAKD;AAbI,GAAP;AAeD,CAjBM","sourcesContent":["import * as fcl from \"@onflow/fcl\";\n//import { getConfig } from \"../../config\";\nimport { sign } from \"./sign\";\n\nfunction getConfig() {\n    const minterAddress = fcl.withPrefix(process.env.REACT_APP_NSFT_CONTRACT);\n    const minterPrivateKeyHex = process.env.REACT_APP_NSFT_PRIVATE_KEY;\n    const minterAccountKeyIndex =\n      process.env.REACT_APP_NSFT_ACCOUNT_KEY_INDEX || 0;\n  \n    return {\n      minterAddress,\n      minterPrivateKeyHex,\n      minterAccountKeyIndex,\n    };\n  }\n\nconst ADDRESS = getConfig().minterAddress;\nconst KEY_ID = getConfig().minterAccountKeyIndex;\n\nexport const authorizationFunction = async (account) => {\n  // authorization function need to return an account\n  return {\n    ...account, // bunch of defaults in here, we want to overload some of them though\n    tempId: `${ADDRESS}|${KEY_ID}`, // tempIds are more of an advanced topic, for 99% of the times where you know the address and keyId you will want it to be a unique string per that address and keyId\n    addr: fcl.sansPrefix(ADDRESS), // the address of the signatory, currently it needs to be without a prefix right now\n    keyId: Number(KEY_ID), // this is the keyId for the accounts registered key that will be used to sign, make extra sure this is a number and not a string\n    signingFunction: async (signable) => {\n      // Singing functions are passed a signable and need to return a composite signature\n      // signable.message is a hex string of what needs to be signed.\n      return {\n        addr: fcl.withPrefix(ADDRESS), // needs to be the same as the account.addr but this time with a prefix, eventually they will both be with a prefix\n        keyId: Number(KEY_ID), // needs to be the same as account.keyId, once again make sure its a number and not a string\n        signature: sign(getConfig().minterPrivateKeyHex, signable.message), // this needs to be a hex string of the signature, where signable.message is the hex value that needs to be signed\n      };\n    },\n  };\n};"]},"metadata":{},"sourceType":"module"}